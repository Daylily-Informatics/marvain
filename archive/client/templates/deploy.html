<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Deploy — marvain</title>
  <style>
    body { font-family: system-ui, -apple-system, Arial, sans-serif; margin: 24px; line-height: 1.35; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 14px; margin: 12px 0; max-width: 760px; }
    label { display:block; margin-top: 10px; font-weight: 600; }
    input { padding: 7px; border-radius: 8px; border: 1px solid #bbb; width: 100%; }
    .btn { padding: 7px 10px; border: 1px solid #bbb; border-radius: 8px; background: #fff; cursor: pointer; }
    .btn:hover { border-color: #888; }
    .muted { color: #666; font-size: 0.92em; }
    code { background: #f6f6f6; padding: 1px 4px; border-radius: 6px; }
  </style>
</head>
<body>
  <h1>Deploy a new agent stack</h1>
  <div class="muted">
    This calls <code>sam build</code> + <code>sam deploy</code> in the background. SAM CLI must be installed.
  </div>

  <div class="card">
    <h2 style="margin-top:0">Sessions</h2>
    <form action="/session/create" method="post">
      <label>Session name</label>
      <input type="text" name="session_name" placeholder="e.g. new-session" required />
      <label>Description</label>
      <input type="text" name="session_description" placeholder="Optional description" />
      <div class="muted">Creates or updates a named session and stores its description + created time.</div>
      <div style="margin-top:10px;">
        <button class="btn" type="submit">Save session</button>
      </div>
    </form>

    <form action="/session/select" method="post" style="margin-top:14px;">
      <label>Select session for this deployment</label>
      <select name="session_name" style="padding: 7px; border-radius: 8px; border: 1px solid #bbb; width: 100%;">
        <option value="" {% if not state.selected_session %}selected{% endif %}>(Generate new session)</option>
        {% for sess in sessions %}
          <option value="{{ sess.name }}" {% if state.selected_session == sess.name %}selected{% endif %}>
            {{ sess.name }} — {{ sess.description or "No description" }} ({{ sess.created }})
          </option>
        {% endfor %}
      </select>
      <div class="muted">Leave blank to create a fresh session when interacting with the stack.</div>
      <div style="margin-top:10px;">
        <button class="btn" type="submit">Use session</button>
      </div>
    </form>
  </div>

  <div class="card">
    <form action="/deploy" method="post">
      <label>Stack name</label>
      <input id="stack_name" name="stack_name" placeholder="marvain-demo" required />
	      <div class="muted">Will be prefixed with {{ state.stack_prefix or 'marvain' }}.</div>
      <div id="stack-name-error" class="muted" style="color: #c00; display: none;"></div>

      <label>Agent ID (AGENT_ID)</label>
      <input name="agent_id" value="marvain-agent" />

      <label>Bedrock MODEL_ID</label>
      <input id="model_id" name="model_id" value="meta.llama3-1-8b-instruct-v1:0" />
      <div class="muted">Validated against Bedrock availability in {{ region }}.</div>
      <div id="model-error" class="muted" style="color: #c00; display: none;"></div>

      <label>Polly voice</label>
      {% if polly_voices %}
        <select id="polly_voice" name="polly_voice" style="padding: 7px; border-radius: 8px; border: 1px solid #bbb; width: 100%;">
          {% for voice in polly_voices %}
            <option value="{{ voice.id }}" data-engines="{{ voice.engines | join(',') }}">
              {{ voice.name }}{% if voice.language %} — {{ voice.language }}{% endif %}
            </option>
          {% endfor %}
        </select>
        <div class="muted">Voices available in region {{ region }} (sorted alphabetically).</div>
      {% else %}
        <input name="polly_voice" value="Matthew" />
        <div class="muted">Unable to load Polly voices; using manual entry.</div>
      {% endif %}

      <label>Voice mode</label>
      <select id="polly_voice_engine" name="polly_voice_engine" style="padding: 7px; border-radius: 8px; border: 1px solid #bbb; width: 100%;">
        <option value="">(auto)</option>
      </select>

      <label>Audio S3 bucket (optional)</label>
      <input id="audio_bucket" name="audio_bucket" placeholder="(blank for inline base64 audio)" />
      <div id="bucket-error" class="muted" style="color: #c00; display: none;"></div>

      <label style="margin-top: 12px;">
        <input type="checkbox" name="verbose" value="1" /> Verbose logging (UI + ./logfs/&lt;stack&gt;-deploy-&lt;timestamp&gt;.log)
      </label>

      <div style="margin-top:14px;">
        <button class="btn" type="submit" id="deploy_btn">Deploy</button>
        <a class="btn" href="/">Cancel</a>
      </div>
    </form>
  </div>

  <div class="card">
    <strong>Notes</strong>
    <ul>
      <li>Region/profile come from Settings (or your shell env).</li>
      <li>Bedrock model availability is region-dependent.</li>
      <li>If you set an audio bucket, you must also grant S3 PutObject permissions (see template.yaml comments).</li>
    </ul>
  </div>

  <script>
    const voiceSelect = document.getElementById('polly_voice');
    const engineSelect = document.getElementById('polly_voice_engine');
    const stackInput = document.getElementById('stack_name');
    const deployButton = document.getElementById('deploy_btn');
    const stackError = document.getElementById('stack-name-error');
    const bucketInput = document.getElementById('audio_bucket');
    const bucketError = document.getElementById('bucket-error');
    const modelInput = document.getElementById('model_id');
    const modelError = document.getElementById('model-error');

    const validationErrors = new Set();

    function toggleDeploy() {
      deployButton.disabled = validationErrors.size > 0;
    }

    function showError(el, key, message) {
      el.textContent = message;
      el.style.display = 'block';
      validationErrors.add(key);
      toggleDeploy();
    }

    function clearError(el, key) {
      el.textContent = '';
      el.style.display = 'none';
      validationErrors.delete(key);
      toggleDeploy();
    }

    async function validateStackName() {
      const rawName = stackInput.value.trim();
      if (!rawName) {
        clearStackError();
        return;
      }

      try {
        const resp = await fetch(`/api/stack_exists?stack_name=${encodeURIComponent(rawName)}`);
        if (!resp.ok) {
          throw new Error('Unable to validate stack name.');
        }
        const data = await resp.json();
        if (data.exists) {
          showError(stackError, 'stack', `Stack "${data.stack_name}" already exists. Please choose a different name.`);
        } else {
          clearError(stackError, 'stack');
        }
      } catch (err) {
        showError(stackError, 'stack', err.message || 'Unable to validate stack name.');
      }
    }

    async function validateBucket() {
      const name = bucketInput.value.trim();
      if (!name) {
        clearError(bucketError, 'bucket');
        return;
      }

      try {
        const resp = await fetch(`/api/bucket_exists?bucket_name=${encodeURIComponent(name)}`);
        if (!resp.ok) throw new Error('Unable to validate bucket.');
        const data = await resp.json();
        if (!data.exists) {
          showError(bucketError, 'bucket', `Bucket "${name}" does not exist.`);
        } else {
          clearError(bucketError, 'bucket');
        }
      } catch (err) {
        showError(bucketError, 'bucket', err.message || 'Unable to validate bucket.');
      }
    }

    async function validateModel() {
      const model = modelInput.value.trim();
      if (!model) {
        clearError(modelError, 'model');
        return;
      }

      try {
        const resp = await fetch(`/api/model_available?model_id=${encodeURIComponent(model)}`);
        if (!resp.ok) throw new Error('Unable to validate model.');
        const data = await resp.json();
        if (!data.available) {
          const detail = data.error ? ` (${data.error})` : '';
          showError(modelError, 'model', `Model "${model}" is not available in ${data.region || 'this region'}.${detail}`);
        } else {
          clearError(modelError, 'model');
        }
      } catch (err) {
        showError(modelError, 'model', err.message || 'Unable to validate model.');
      }
    }

    function updateEngineOptions() {
      if (!voiceSelect) return;
      const selected = voiceSelect.options[voiceSelect.selectedIndex];
      const enginesRaw = selected ? selected.dataset.engines || '' : '';
      const engines = enginesRaw.split(',').filter(Boolean);

      engineSelect.innerHTML = '';
      const autoOpt = document.createElement('option');
      autoOpt.value = '';
      autoOpt.textContent = '(auto)';
      engineSelect.appendChild(autoOpt);

      engines.forEach((engine) => {
        const opt = document.createElement('option');
        opt.value = engine;
        opt.textContent = engine.charAt(0).toUpperCase() + engine.slice(1);
        engineSelect.appendChild(opt);
      });
    }

    voiceSelect?.addEventListener('change', updateEngineOptions);
    stackInput?.addEventListener('blur', validateStackName);
    stackInput?.addEventListener('change', validateStackName);
    stackInput?.addEventListener('input', () => {
      if (!stackInput.value.trim()) {
        clearError(stackError, 'stack');
      }
    });
    bucketInput?.addEventListener('blur', validateBucket);
    bucketInput?.addEventListener('change', validateBucket);
    modelInput?.addEventListener('blur', validateModel);
    modelInput?.addEventListener('change', validateModel);
    updateEngineOptions();
  </script>
</body>
</html>
